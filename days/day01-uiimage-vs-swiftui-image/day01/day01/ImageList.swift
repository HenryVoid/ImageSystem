//
//  ImageList.swift
//  day01
//
//  7) SwiftUI/UIViewControllerÏóê "ÏºÄÏù¥Î∏î Ïó∞Í≤∞" ÏòàÏãú
//  Î™®Îì† ÏÑ±Îä• Ï∏°Ï†ï ÎèÑÍµ¨Î•º Ïã§Ï†úÎ°ú Ï†ÅÏö©
//  ‚úÖ Î©îÎ™®Î¶¨ ÎàÑÏàò & UI Hangs Ìï¥Í≤∞ Î≤ÑÏ†Ñ
//

import SwiftUI
import UIKit
import os

// MARK: - SwiftUI Î≤ÑÏ†Ñ (ÏµúÏ†ÅÌôî ÏôÑÎ£å)
let maxCount: Int = 1000

struct SwiftUIImageList: View {
  // ‚úÖ Ïù¥ÎØ∏ÏßÄ Ï∫êÏãú Í¥ÄÎ¶¨
  @StateObject private var imageCache = ImageCacheManager.shared
  private let renderSignpost = Signpost.swiftUIRender(label: "ImageList")
  
  var body: some View {
    ScrollView {
      LazyVStack {
        ForEach(0..<maxCount, id: \.self) { index in
          // ‚úÖ ÏµúÏ†ÅÌôîÎêú Ïù¥ÎØ∏ÏßÄ Î∑∞
          OptimizedSwiftUIImage()
            .frame(height: 120)
            .padding(.horizontal)
        }
      }
    }
    .coordinateSpace(name: "scroll")
    .detectScrollWithSignpost(name: "SwiftUI_ImageList")
    .showFPS()
    .showMemory()
    .onAppear {
      PerformanceLogger.log("‚úÖ SwiftUI Ïù¥ÎØ∏ÏßÄ Î¶¨Ïä§Ìä∏ ÏãúÏûë")
      MemorySampler.logCurrentMemory(label: "SwiftUI onAppear")
      renderSignpost.begin()
    }
    .onDisappear {
      PerformanceLogger.log("‚ùå SwiftUI Ïù¥ÎØ∏ÏßÄ Î¶¨Ïä§Ìä∏ Ï¢ÖÎ£å")
      renderSignpost.end()
      
      // ‚úÖ Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
      imageCache.clearCache()
    }
  }
}

// MARK: - ÏµúÏ†ÅÌôîÎêú SwiftUI Ïù¥ÎØ∏ÏßÄ Î∑∞
private struct OptimizedSwiftUIImage: View {
  @State private var preparedImage: UIImage?
  
  var body: some View {
    Group {
      if let image = preparedImage {
        Image(uiImage: image)
          .resizable()
          .scaledToFit()
      } else {
        ProgressView()
      }
    }
    .task {
      // ‚úÖ Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú Ïù¥ÎØ∏ÏßÄ ÎîîÏΩîÎî©
      await loadAndPrepareImage()
    }
  }
  
  @MainActor
  private func loadAndPrepareImage() async {
    await Task.detached(priority: .userInitiated) {
      guard let image = UIImage(named: "sample") else { return }
      
      // ‚úÖ iOS 15+ preparingForDisplay() ÏÇ¨Ïö©
      let prepared: UIImage
      if #available(iOS 15.0, *) {
        prepared = image.preparingForDisplay() ?? image
      } else {
        // iOS 15 ÎØ∏ÎßåÏùÄ ÏàòÎèô ÎîîÏΩîÎî©
        prepared = Self.decodeImage(image) ?? image
      }
      
      await MainActor.run {
        self.preparedImage = prepared
      }
    }.value
  }
  
  // iOS 15 ÎØ∏ÎßåÏùÑ ÏúÑÌïú ÏàòÎèô Ïù¥ÎØ∏ÏßÄ ÎîîÏΩîÎî©
  private static func decodeImage(_ image: UIImage) -> UIImage? {
    guard let cgImage = image.cgImage else { return nil }
    
    let colorSpace = CGColorSpaceCreateDeviceRGB()
    let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
    
    guard let context = CGContext(
      data: nil,
      width: cgImage.width,
      height: cgImage.height,
      bitsPerComponent: 8,
      bytesPerRow: cgImage.width * 4,
      space: colorSpace,
      bitmapInfo: bitmapInfo.rawValue
    ) else { return nil }
    
    let rect = CGRect(x: 0, y: 0, width: cgImage.width, height: cgImage.height)
    context.draw(cgImage, in: rect)
    
    guard let decodedImage = context.makeImage() else { return nil }
    return UIImage(cgImage: decodedImage)
  }
}

// MARK: - Ïù¥ÎØ∏ÏßÄ Ï∫êÏãú Îß§ÎãàÏ†Ä
class ImageCacheManager: ObservableObject {
  static let shared = ImageCacheManager()
  
  private var cache: [String: UIImage] = [:]
  private let queue = DispatchQueue(label: "com.day01.imageCache", attributes: .concurrent)
  
  private init() {
    // ‚úÖ Î©îÎ™®Î¶¨ ÏõåÎãù Í∞êÏßÄ
    NotificationCenter.default.addObserver(
      self,
      selector: #selector(didReceiveMemoryWarning),
      name: UIApplication.didReceiveMemoryWarningNotification,
      object: nil
    )
  }
  
  deinit {
    // ‚úÖ Observer Ï†úÍ±∞
    NotificationCenter.default.removeObserver(self)
  }
  
  @objc private func didReceiveMemoryWarning() {
    PerformanceLogger.log("‚ö†Ô∏è Î©îÎ™®Î¶¨ ÏõåÎãù - Ï∫êÏãú Ï†ïÎ¶¨")
    clearCache()
  }
  
  func clearCache() {
    queue.async(flags: .barrier) { [weak self] in
      self?.cache.removeAll()
    }
  }
}

// MARK: - UIKit Î≤ÑÏ†Ñ (ÏµúÏ†ÅÌôî ÏôÑÎ£å)

class UIKitImageListViewController: UIViewController {
  // ‚úÖ UICollectionViewÎ°ú Î≥ÄÍ≤Ω (Ïû¨ÏÇ¨Ïö© Í∞ÄÎä•)
  private var collectionView: UICollectionView!
  
  // ‚úÖ Ïä§ÌÅ¨Î°§ Í∞êÏßÄ Îç∏Î¶¨Í≤åÏù¥Ìä∏
  private lazy var scrollDetector = ScrollDetectorDelegate(name: "UIKit_ImageList")
  
  // ‚úÖ FPS/Î©îÎ™®Î¶¨ Î™®ÎãàÌÑ∞
  private var displayLink: CADisplayLink?
  private var lastTimestamp: CFTimeInterval = 0
  private var frameCount: Int = 0
  private var memoryMonitor: MemoryMonitor?
  
  // ‚úÖ ÏÑ±Îä• Ï∏°Ï†ï
  private let renderSignpost = Signpost.uikitRender(label: "ImageList")
  
  // Ïò§Î≤ÑÎ†àÏù¥ Î†àÏù¥Î∏îÎì§
  private let fpsLabel = UILabel()
  private let memoryLabel = UILabel()
  
  // ‚úÖ Ï§ÄÎπÑÎêú Ïù¥ÎØ∏ÏßÄ Ï∫êÏãú
  private var preparedImage: UIImage?
  
  override func viewDidLoad() {
    super.viewDidLoad()
    
    PerformanceLogger.log("‚úÖ UIKit Ïù¥ÎØ∏ÏßÄ Î¶¨Ïä§Ìä∏ ÏãúÏûë")
    MemorySampler.logCurrentMemory(label: "UIKit viewDidLoad")
    
    setupCollectionView()
    setupOverlays()
    prepareImage()
    
    renderSignpost.begin()
  }
  
  override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
    
    // ‚úÖ FPS Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
    startFPSMonitoring()
    
    // ‚úÖ Î©îÎ™®Î¶¨ Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë
    memoryMonitor = MemoryMonitor(interval: 2.0)
    memoryMonitor?.startMonitoring()
    
    // Î†åÎçîÎßÅ ÏôÑÎ£å
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) { [weak self] in
      self?.renderSignpost.end()
    }
  }
  
  override func viewWillDisappear(_ animated: Bool) {
    super.viewWillDisappear(animated)
    
    PerformanceLogger.log("‚ùå UIKit Ïù¥ÎØ∏ÏßÄ Î¶¨Ïä§Ìä∏ Ï¢ÖÎ£å")
    stopFPSMonitoring()
    memoryMonitor?.stopMonitoring()
  }
  
  deinit {
    // ‚úÖ Î¶¨ÏÜåÏä§ Ï†ïÎ¶¨
    PerformanceLogger.log("üóëÔ∏è UIKit Ïù¥ÎØ∏ÏßÄ Î¶¨Ïä§Ìä∏ deinit")
    stopFPSMonitoring()
    memoryMonitor?.stopMonitoring()
    memoryMonitor = nil
    preparedImage = nil
    collectionView = nil
  }
  
  // ‚úÖ Ïù¥ÎØ∏ÏßÄ ÏÇ¨Ï†Ñ ÎîîÏΩîÎî©
  private func prepareImage() {
    Task.detached(priority: .userInitiated) { [weak self] in
      guard let image = UIImage(named: "sample") else { return }
      
      // iOS 15+ preparingForDisplay() ÏÇ¨Ïö©
      let prepared: UIImage
      if #available(iOS 15.0, *) {
        prepared = image.preparingForDisplay() ?? image
      } else {
        // ÏàòÎèô ÎîîÏΩîÎî©
        prepared = self?.decodeImage(image) ?? image
      }
      
      await MainActor.run { [weak self] in
        self?.preparedImage = prepared
        self?.collectionView.reloadData()
      }
    }
  }
  
  // ÏàòÎèô Ïù¥ÎØ∏ÏßÄ ÎîîÏΩîÎî© (iOS 15 ÎØ∏Îßå)
  private func decodeImage(_ image: UIImage) -> UIImage {
    guard let cgImage = image.cgImage else { return image }
    
    let colorSpace = CGColorSpaceCreateDeviceRGB()
    let bitmapInfo = CGBitmapInfo(rawValue: CGImageAlphaInfo.premultipliedLast.rawValue)
    
    guard let context = CGContext(
      data: nil,
      width: cgImage.width,
      height: cgImage.height,
      bitsPerComponent: 8,
      bytesPerRow: cgImage.width * 4,
      space: colorSpace,
      bitmapInfo: bitmapInfo.rawValue
    ) else { return image }
    
    let rect = CGRect(x: 0, y: 0, width: cgImage.width, height: cgImage.height)
    context.draw(cgImage, in: rect)
    
    guard let decodedImage = context.makeImage() else { return image }
    return UIImage(cgImage: decodedImage)
  }
  
  private func setupCollectionView() {
    view.backgroundColor = .systemBackground
    
    // ‚úÖ UICollectionViewFlowLayout ÏÑ§Ï†ï
    let layout = UICollectionViewFlowLayout()
    layout.scrollDirection = .vertical
    layout.minimumLineSpacing = 8
    layout.itemSize = CGSize(width: UIScreen.main.bounds.width - 32, height: 120)
    
    // ‚úÖ UICollectionView ÏÉùÏÑ±
    collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)
    collectionView.backgroundColor = .systemBackground
    collectionView.translatesAutoresizingMaskIntoConstraints = false
    collectionView.delegate = self
    collectionView.dataSource = self
    
    // ‚úÖ ÏÖÄ Îì±Î°ù
    collectionView.register(
      OptimizedImageCell.self,
      forCellWithReuseIdentifier: OptimizedImageCell.identifier
    )
    
    view.addSubview(collectionView)
    
    NSLayoutConstraint.activate([
      collectionView.topAnchor.constraint(equalTo: view.topAnchor),
      collectionView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
      collectionView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
      collectionView.trailingAnchor.constraint(equalTo: view.trailingAnchor)
    ])
  }
  
  // MARK: - üéØ FPS Ïò§Î≤ÑÎ†àÏù¥
  
  private func setupOverlays() {
    // FPS Î†àÏù¥Î∏î
    fpsLabel.font = .monospacedSystemFont(ofSize: 12, weight: .regular)
    fpsLabel.textColor = .white
    fpsLabel.backgroundColor = UIColor.green.withAlphaComponent(0.8)
    fpsLabel.textAlignment = .center
    fpsLabel.layer.cornerRadius = 8
    fpsLabel.clipsToBounds = true
    fpsLabel.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(fpsLabel)
    
    // Î©îÎ™®Î¶¨ Î†àÏù¥Î∏î
    memoryLabel.font = .monospacedSystemFont(ofSize: 12, weight: .regular)
    memoryLabel.textColor = .white
    memoryLabel.backgroundColor = UIColor.purple.withAlphaComponent(0.8)
    memoryLabel.textAlignment = .center
    memoryLabel.layer.cornerRadius = 8
    memoryLabel.clipsToBounds = true
    memoryLabel.translatesAutoresizingMaskIntoConstraints = false
    view.addSubview(memoryLabel)
    
    NSLayoutConstraint.activate([
      fpsLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 8),
      fpsLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -8),
      fpsLabel.widthAnchor.constraint(equalToConstant: 80),
      fpsLabel.heightAnchor.constraint(equalToConstant: 32),
      
      memoryLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 8),
      memoryLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 8),
      memoryLabel.widthAnchor.constraint(equalToConstant: 100),
      memoryLabel.heightAnchor.constraint(equalToConstant: 32)
    ])
  }
  
  private func startFPSMonitoring() {
    // ‚úÖ weak selfÎ°ú ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄ
    displayLink = CADisplayLink(target: WeakDisplayLinkTarget(target: self), selector: #selector(WeakDisplayLinkTarget.tick(_:)))
    displayLink?.add(to: .main, forMode: .common)
  }
  
  private func stopFPSMonitoring() {
    displayLink?.invalidate()
    displayLink = nil
  }
  
  @objc func displayLinkTick(displayLink: CADisplayLink) {
    if lastTimestamp == 0 {
      lastTimestamp = displayLink.timestamp
      return
    }
    
    frameCount += 1
    let elapsed = displayLink.timestamp - lastTimestamp
    
    if elapsed >= 1.0 {
      let fps = Double(frameCount) / elapsed
      let fpsInt = Int(fps.rounded())
      
      fpsLabel.text = "\(fpsInt) FPS"
      fpsLabel.backgroundColor = fpsColor(for: fpsInt)
      
      PerformanceLogger.log("FPS: \(fpsInt)", category: "fps")
      
      frameCount = 0
      lastTimestamp = displayLink.timestamp
    }
    
    // Î©îÎ™®Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
    let bytes = MemorySampler.currentMemoryUsage()
    memoryLabel.text = "üß† " + MemorySampler.formatBytes(bytes)
  }
  
  private func fpsColor(for fps: Int) -> UIColor {
    switch fps {
    case 55...Int.max: return UIColor.green.withAlphaComponent(0.8)
    case 40..<55: return UIColor.yellow.withAlphaComponent(0.8)
    case 30..<40: return UIColor.orange.withAlphaComponent(0.8)
    default: return UIColor.red.withAlphaComponent(0.8)
    }
  }
}

// MARK: - UICollectionView DataSource & Delegate

extension UIKitImageListViewController: UICollectionViewDataSource, UICollectionViewDelegate {
  func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
    return maxCount
  }
  
  func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
    guard let cell = collectionView.dequeueReusableCell(
      withReuseIdentifier: OptimizedImageCell.identifier,
      for: indexPath
    ) as? OptimizedImageCell else {
      return UICollectionViewCell()
    }
    
    // ‚úÖ Ï§ÄÎπÑÎêú Ïù¥ÎØ∏ÏßÄ ÏÇ¨Ïö©
    cell.configure(with: preparedImage)
    return cell
  }
}

// MARK: - ÏµúÏ†ÅÌôîÎêú Ïù¥ÎØ∏ÏßÄ ÏÖÄ

class OptimizedImageCell: UICollectionViewCell {
  static let identifier = "OptimizedImageCell"
  
  private let imageView = UIImageView()
  
  override init(frame: CGRect) {
    super.init(frame: frame)
    setupImageView()
  }
  
  required init?(coder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
  }
  
  private func setupImageView() {
    imageView.contentMode = .scaleAspectFit
    imageView.translatesAutoresizingMaskIntoConstraints = false
    contentView.addSubview(imageView)
    
    NSLayoutConstraint.activate([
      imageView.topAnchor.constraint(equalTo: contentView.topAnchor),
      imageView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
      imageView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 16),
      imageView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -16)
    ])
  }
  
  func configure(with image: UIImage?) {
    imageView.image = image
  }
  
  // ‚úÖ ÏÖÄ Ïû¨ÏÇ¨Ïö© Ïãú Ïù¥ÎØ∏ÏßÄ Ï†ïÎ¶¨
  override func prepareForReuse() {
    super.prepareForReuse()
    imageView.image = nil
  }
  
  deinit {
    // ‚úÖ Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
    imageView.image = nil
  }
}

// MARK: - Weak DisplayLink Target (ÏàúÌôò Ï∞∏Ï°∞ Î∞©ÏßÄ)

class WeakDisplayLinkTarget {
  private weak var target: UIKitImageListViewController?
  
  init(target: UIKitImageListViewController) {
    self.target = target
  }
  
  @objc func tick(_ displayLink: CADisplayLink) {
    target?.displayLinkTick(displayLink: displayLink)
  }
}

// MARK: - SwiftUI Representable Wrapper

struct UIKitListRepresentable: UIViewControllerRepresentable {
  func makeUIViewController(context: Context) -> UIViewController {
    return UIKitImageListViewController()
  }
  
  func updateUIViewController(_ uiViewController: UIViewController, context: Context) {
    // ÏóÖÎç∞Ïù¥Ìä∏ ÏóÜÏùå
  }
}
