# 시작하기

> Day 8 URLSession 비동기 이미지 로딩 빠른 시작 가이드

---

## 🚀 빠른 시작

### 1. 프로젝트 열기

```bash
cd /Users/woogi/Documents/ImageSystem/days/day08
open day08.xcodeproj
```

### 2. 빌드 및 실행

```
⌘R (Run)
```

### 3. 네트워크 연결 확인

⚠️ **중요**: 이 프로젝트는 인터넷 연결이 필요합니다.

- Wi-Fi 또는 LTE 연결 확인
- 무료 이미지 API 사용: [Picsum Photos](https://picsum.photos)
- 데이터 사용량: 약 1-2MB

---

## 📱 앱 사용 방법

### Tab 1: 기본 로딩 (캐시 없음)

**목적**: URLSession의 기본 동작 이해

1. "이미지 로드" 버튼 클릭
2. 로딩 인디케이터 확인
3. 로딩 시간 확인 (약 500ms)
4. "다시 로드" 버튼 클릭
5. 또 500ms 소요 확인 (매번 다운로드)

**학습 포인트**:
- URLSession.shared.dataTask 기본 사용법
- completion handler 패턴
- DispatchQueue.main.async의 필요성
- 매번 네트워크 요청하는 비효율

---

### Tab 2: 캐시 적용

**목적**: NSCache를 활용한 성능 개선

1. "이미지 로드" 버튼 클릭
2. "캐시 미스" 메시지 확인
3. 로딩 시간 확인 (약 500ms)
4. "다시 로드" 버튼 클릭
5. "캐시 히트" 메시지 확인
6. 로딩 시간 확인 (약 5ms) ⚡ **100배 빠름!**
7. "캐시 초기화" 버튼으로 테스트 반복

**학습 포인트**:
- NSCache 사용법
- 캐시 히트 vs 캐시 미스
- 캐시 키 설계 (URL 기반)
- 성능 개선 체감 (500ms → 5ms)

---

### Tab 3: 비교 테스트

**목적**: 캐시 적용 전후 직접 비교

1. "테스트 시작" 버튼 클릭
2. 좌측 (캐시 없음) vs 우측 (캐시 적용)
3. 10개 이미지 로딩 시간 비교
4. "2차 로드" 버튼으로 재테스트
5. 캐시의 효과 확인:
   - 캐시 없음: 5000ms
   - 캐시 적용: 50ms
   - **100배 차이!**

**학습 포인트**:
- 캐시의 실질적 효과
- 네트워크 트래픽 절감
- 사용자 경험 개선

---

### Tab 4: 벤치마크

**목적**: 정밀한 성능 측정

1. "전체 벤치마크" 버튼 클릭
2. 각 테스트 진행 상황 확인
3. 결과 확인:
   - 평균 시간
   - 최소/최대 시간
   - 캐시 히트율
4. "상세 결과" 버튼으로 통계 확인

**학습 포인트**:
- 반복 테스트의 중요성
- 통계적 성능 측정
- 캐시 히트율 최적화

---

## 📖 학습 순서 (권장)

### 1단계: 이론 학습 (30분)

먼저 이론 문서를 순서대로 읽어보세요:

1. **URLSESSION_THEORY.md** (15분)
   - URLSession 기본 구조
   - 네트워크 요청 생명주기
   - 메인/백그라운드 스레드
   - weak self 필요성

2. **ASYNC_AWAIT_GUIDE.md** (10분)
   - completion handler vs async/await
   - Task와 MainActor
   - 에러 처리 비교

3. **CACHING_GUIDE.md** (10분)
   - NSCache 사용법
   - 캐시 키 설계
   - 중복 요청 방지

4. **PERFORMANCE_GUIDE.md** (5분)
   - 성능 비교
   - 최적화 기법
   - Instruments 활용

---

### 2단계: 앱 실습 (30분)

이론을 바탕으로 앱을 실제로 사용:

**Tab 1 실습** (5분):
- 기본 로딩 테스트
- 로딩 시간 관찰
- 반복 로딩 시 매번 느린 것 확인

**Tab 2 실습** (10분):
- 첫 로드 vs 재로드 비교
- 캐시 히트/미스 메시지 확인
- 캐시 초기화 후 재테스트
- 5ms vs 500ms 체감

**Tab 3 실습** (10분):
- 좌우 비교 테스트
- 1차 vs 2차 로드 비교
- 네트워크 트래픽 차이 확인

**Tab 4 실습** (5분):
- 벤치마크 실행
- 통계 결과 분석

---

### 3단계: 코드 분석 (1시간)

코드를 직접 읽고 이해:

**Core/ 모듈** (30분):
1. `SimpleImageLoader.swift` 읽기
   - URLSession.shared.dataTask 사용법
   - completion handler 패턴
   - DispatchQueue.main.async

2. `CachedImageLoader.swift` 읽기
   - NSCache 생성 및 설정
   - 캐시 히트/미스 로직
   - 중복 요청 방지 (runningRequests)

3. `AsyncImageLoader.swift` 읽기
   - async/await 구현
   - Task 사용법
   - 에러 처리

**Views/ 모듈** (20분):
1. `SimpleLoadingView.swift`
2. `CachedLoadingView.swift`
3. `ComparisonView.swift`
4. `BenchmarkView.swift`

**tool/ 모듈** (10분):
1. `PerformanceLogger.swift` - os_signpost 활용
2. `MemorySampler.swift` - 메모리 측정
3. `NetworkMonitor.swift` - 네트워크 상태

---

### 4단계: Instruments 프로파일링 (30분, 선택)

**Logging (signpost 확인)**:

1. ⌘I (Product > Profile)
2. **Logging** 템플릿 선택
3. Record 시작
4. 앱의 **벤치마크** 탭 실행
5. "전체 벤치마크" 실행
6. Stop 버튼
7. **Points of Interest** 확인

**확인할 signpost**:
- `Image_Load_NoCache`: 캐시 없는 로딩 시간
- `Image_Load_Cached`: 캐시 로딩 시간
- `Cache_Hit`: 캐시에서 가져온 시간
- `Cache_Miss`: 네트워크에서 다운로드한 시간

**Network (트래픽 확인)**:

1. ⌘I (Product > Profile)
2. **Network** 템플릿 선택
3. Record 시작
4. 앱에서 이미지 로딩
5. Stop 버튼
6. **Connections** 탭에서 다운로드 확인

**확인 사항**:
- 총 다운로드 크기
- 요청 URL 목록
- 중복 요청 여부
- 캐시 적용 시 트래픽 감소 확인

---

## 🔧 프로젝트 설정

### 최소 요구사항

- **Xcode**: 14.0+
- **iOS Deployment Target**: 15.0+
- **Swift**: 5.5+ (async/await 지원)
- **인터넷 연결**: 필수

### 의존성

**기본 프레임워크** (추가 설치 불필요):
- Foundation (URLSession)
- UIKit (UIImage)
- SwiftUI (UI)
- os (os_signpost)

**외부 라이브러리**: 없음

---

## ⚙️ 설정 커스터마이징

### 캐시 크기 조정

`CachedImageLoader.swift`:

```swift
// 기본값: 100MB, 50개
cache.totalCostLimit = 100 * 1024 * 1024
cache.countLimit = 50

// 작은 기기용: 50MB, 30개
cache.totalCostLimit = 50 * 1024 * 1024
cache.countLimit = 30

// 큰 기기용: 200MB, 100개
cache.totalCostLimit = 200 * 1024 * 1024
cache.countLimit = 100
```

---

### 이미지 URL 변경

`ComparisonView.swift` 또는 `BenchmarkView.swift`:

```swift
// 기본 (Picsum Photos)
let urls = (1...10).map { 
    URL(string: "https://picsum.photos/800/600?random=\($0)")!
}

// 다른 API 사용
let urls = [
    URL(string: "https://your-api.com/image1.jpg")!,
    URL(string: "https://your-api.com/image2.jpg")!,
    // ...
]
```

---

### 타임아웃 설정

`SimpleImageLoader.swift`:

```swift
var request = URLRequest(url: url)
request.timeoutInterval = 15  // 15초 (기본 60초)
```

---

## 🐛 문제 해결

### 이미지가 로드되지 않음

**증상**: 계속 로딩 중이거나 에러 메시지

**원인 1**: 인터넷 연결 끊김
- **해결**: Wi-Fi 연결 확인

**원인 2**: 시뮬레이터 네트워크 문제
- **해결**: 시뮬레이터 재시작
  ```
  Device > Erase All Content and Settings
  ```

**원인 3**: API 서버 문제
- **해결**: Safari에서 URL 직접 접속 테스트
  ```
  https://picsum.photos/800/600
  ```

---

### 앱이 멈추거나 크래시

**증상**: UI가 응답 없음 또는 크래시

**원인 1**: 메인 스레드 차단
- **해결**: `DispatchQueue.main.async` 사용 확인

**원인 2**: 메모리 부족
- **해결**: 캐시 크기 제한
  ```swift
  cache.totalCostLimit = 50 * 1024 * 1024  // 50MB
  ```

**원인 3**: 강한 참조 순환
- **해결**: `[weak self]` 사용 확인

---

### Instruments에서 signpost가 안 보임

**증상**: Points of Interest 비어 있음

**원인**: Logging 템플릿 미사용
- **해결**: 
  1. ⌘I 후 **Logging** 선택 (Time Profiler 아님!)
  2. 벤치마크 실행 확인
  3. Filter에서 "com.study.day08" 검색

---

### 시뮬레이터에서 너무 빠름

**증상**: 캐시 없어도 매우 빠름

**원인**: 시뮬레이터는 Mac 네트워크 사용 (로컬호스트처럼 빠름)
- **해결**: 실제 기기에서 테스트
  - iPhone/iPad 연결
  - ⌘R로 실행
  - 4G/5G 환경에서 테스트

---

## 💡 실전 팁

### 1. 콘솔 로그 활용

Console.app에서 실시간 로그 확인:

1. Console.app 실행 (Spotlight 검색)
2. 시뮬레이터/기기 선택
3. 필터 입력: `subsystem:com.study.day08`
4. 앱 실행 및 작업
5. 로그 확인:
   ```
   ✅ 캐시 히트: https://picsum.photos/800/600?random=1
   ❌ 캐시 미스: https://picsum.photos/800/600?random=2
   ```

---

### 2. 네트워크 속도 시뮬레이션

느린 네트워크 환경 테스트:

1. Xcode 메뉴: Debug > Simulate Location
2. Settings > Developer > Network Link Conditioner
3. **Enable** 체크
4. Profile 선택:
   - 3G (느림)
   - LTE (보통)
   - WiFi (빠름)

**효과**: 실제 네트워크 환경과 유사한 테스트 가능

---

### 3. 캐시 효과 극대화

캐시 히트율을 높이는 방법:

1. **동일 이미지 재사용**: 같은 URL 반복 로드
2. **프리로딩**: 미리 캐시에 저장
3. **적절한 캐시 크기**: 너무 작으면 자주 삭제됨

```swift
// 앱 시작 시 자주 쓰는 이미지 프리로드
func prefetchImages() {
    let commonURLs = [/* 자주 쓰는 URL들 */]
    for url in commonURLs {
        CachedImageLoader.shared.loadImage(from: url) { _ in }
    }
}
```

---

## 🎯 학습 목표 달성 체크

### 기본 (필수)

- [ ] URLSession.shared.dataTask 사용법 이해
- [ ] completion handler 패턴 숙지
- [ ] DispatchQueue.main.async 필요성 이해
- [ ] NSCache 기본 사용법 숙지
- [ ] 캐시 히트/미스 개념 이해
- [ ] 캐시 적용 전후 성능 차이 체감

### 응용

- [ ] weak self 사용 이유 이해
- [ ] 중복 요청 방지 로직 이해
- [ ] async/await 버전 구현 비교
- [ ] 캐시 키 설계 전략 이해
- [ ] 메모리 경고 처리 방법 파악

### 심화 (선택)

- [ ] os_signpost 활용법 숙지
- [ ] Instruments Logging으로 성능 분석
- [ ] Network Instrument로 트래픽 분석
- [ ] 캐시 히트율 최적화 전략 수립
- [ ] 자신의 프로젝트에 적용

---

## 📚 다음 단계

Day 8을 완료했다면:

### 1. 실전 적용

**자신의 앱에 적용**:
- AsyncImage 대신 CachedImageLoader 사용
- 네트워크 트래픽 감소 확인
- 사용자 경험 개선 측정

### 2. 기능 확장

**디스크 캐시 추가**:
- URLCache 활용
- 영구 저장소 구현
- 오프라인 모드 지원

**이미지 프리로딩**:
- 스크롤 예측
- 백그라운드 프리페치
- 우선순위 관리

**다운샘플링**:
- ImageIO 활용
- 메모리 최적화
- 품질 유지

### 3. 고급 최적화

**병렬 다운로드**:
```swift
// TaskGroup으로 동시 다운로드
let images = try await withThrowingTaskGroup(of: UIImage.self) { group in
    for url in urls {
        group.addTask { try await loadImage(url: url) }
    }
    return try await group.reduce(into: []) { $0.append($1) }
}
```

**점진적 로딩**:
- Progressive JPEG 지원
- 단계적 이미지 표시
- UX 개선

---

## 📞 참고 자료

### 프로젝트 문서

- **README.md**: 전체 개요
- **URLSESSION_THEORY.md**: URLSession 상세 이론
- **ASYNC_AWAIT_GUIDE.md**: async/await 가이드
- **CACHING_GUIDE.md**: 캐싱 전략
- **PERFORMANCE_GUIDE.md**: 성능 최적화

### Apple 공식 문서

- [URLSession](https://developer.apple.com/documentation/foundation/urlsession)
- [NSCache](https://developer.apple.com/documentation/foundation/nscache)
- [Swift Concurrency](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html)

---

**즐거운 학습 되세요! 🎉**

*URLSession과 캐싱을 마스터하여 효율적인 이미지 로딩을 구현하세요!*

