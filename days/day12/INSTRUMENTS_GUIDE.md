# Instruments 사용 가이드

> Instruments로 iOS 앱의 프레임 타임, 메모리, 네트워크 성능을 측정하는 완벽한 가이드

---

## 📚 목차

1. [Instruments 소개](#instruments-소개)
2. [시작하기](#시작하기)
3. [Time Profiler (프레임 타임)](#time-profiler-프레임-타임)
4. [Allocations (메모리)](#allocations-메모리)
5. [Network (네트워크)](#network-네트워크)
6. [실전 시나리오](#실전-시나리오)
7. [성능 분석 팁](#성능-분석-팁)

---

## Instruments 소개

### Instruments란?

**Instruments**는 Apple이 제공하는 강력한 성능 분석 도구입니다.

**주요 기능**:
- ⚡ **Time Profiler**: CPU 사용량, 함수 호출 시간
- 💾 **Allocations**: 메모리 할당 및 누수
- 🌐 **Network**: 네트워크 트래픽
- 🎨 **Core Animation**: 프레임 드롭, 렌더링
- 🔋 **Energy Log**: 배터리 사용량

### 왜 Instruments를 사용하는가?

```
앱 내 모니터링 vs Instruments

앱 내 모니터링:
✅ 실시간 정보
✅ 개발 중 빠른 확인
❌ 정확도 낮음 (앱 오버헤드)
❌ 상세 분석 불가

Instruments:
✅ 매우 정확한 측정
✅ 심층 분석 가능
✅ 병목 지점 파악
✅ 타임라인 뷰
❌ 실시간이 아님 (기록 후 분석)
```

---

## 시작하기

### 1. Instruments 실행

**방법 1: 메뉴에서**
```
Xcode → Product → Profile (⌘I)
```

**방법 2: 단축키**
```
⌘I (Command + I)
```

**결과**: 앱이 Release 모드로 빌드되고 Instruments가 실행됩니다.

### 2. 템플릿 선택

Instruments 시작 화면에서 템플릿을 선택합니다:

```
┌─────────────────────────────────┐
│   Choose a Profiling Template   │
├─────────────────────────────────┤
│  ⚡ Time Profiler               │ ← CPU 분석
│  💾 Allocations                 │ ← 메모리 분석
│  🌐 Network                     │ ← 네트워크 분석
│  🎨 Core Animation              │ ← 렌더링 분석
│  🔋 Energy Log                  │ ← 배터리 분석
│  📊 Blank                       │ ← 커스텀
└─────────────────────────────────┘
```

### 3. 기본 인터페이스

```
┌────────────────────────────────────────────────┐
│  ▶ Record   ⏸ Pause   ⏹ Stop      [00:45]     │ ← 컨트롤
├────────────────────────────────────────────────┤
│                                                 │
│        📊 Timeline (시간 흐름)                   │
│        CPU: ▂▃▅▇█▇▅▃▂                          │
│        Memory: ▁▂▂▃▃▄▄▅▆▆▇                      │
│                                                 │
├────────────────────────────────────────────────┤
│  Detail Pane                                   │
│  - 함수 목록                                     │
│  - 호출 스택                                     │
│  - 시간 분포                                     │
└────────────────────────────────────────────────┘
```

---

## Time Profiler (프레임 타임)

### 목적

- CPU 사용률 측정
- 어느 함수가 시간을 많이 소비하는지 파악
- 프레임 드롭 원인 찾기

### 실행 단계

#### 1단계: 프로파일링 시작

```
1. Xcode에서 ⌘I
2. "Time Profiler" 선택
3. 빨간색 Record 버튼 클릭 ●
4. 앱이 실행됨
```

#### 2단계: 테스트 시나리오 수행

```
앱에서 측정하고 싶은 동작 수행:

예시: 1000개 이미지 리스트 스크롤
1. Tab 1으로 이동
2. 1000개 선택
3. 빠르게 위아래 스크롤 (10초)
4. Instruments에서 Stop 버튼 클릭 ⏹
```

#### 3단계: 데이터 분석

**Timeline 확인**:
```
CPU Usage
100% │     █
     │    ███
 50% │   █████     ← 스크롤 중 CPU 스파이크
     │  ███████
  0% │───────────────────────────
     0s  5s  10s 15s 20s
```

**Call Tree 보기**:
```
Settings (오른쪽 상단):
☑ Separate by Thread    (스레드별 분리)
☑ Invert Call Tree      (호출 역순 - 중요!)
☑ Hide System Libraries (시스템 함수 숨김)
```

**함수 목록**:
```
Function Name                  Time (ms)  %
─────────────────────────────────────────
AsyncImage.load()                 3200   40%  ← 가장 많은 시간
├─ URLSession.data()              2400   30%
└─ Image.decode()                  800   10%

LazyVStack.body                   1600   20%
├─ View.layout()                   800   10%
└─ View.render()                   800   10%

Other                             3200   40%
─────────────────────────────────────────
Total                             8000  100%
```

#### 4단계: 병목 지점 파악

**분석**:
1. 가장 많은 시간을 소비하는 함수 찾기
2. 해당 함수의 호출 스택 확인
3. 최적화 가능 여부 판단

**예시**:
```
Image.decode()가 800ms (10%)
→ 이미지 디코딩이 병목
→ 해결: 다운샘플링으로 이미지 크기 축소
```

### 프레임 타임 계산

```
60fps 목표 = 16.67ms per frame

프레임별 시간 측정:
Frame 1: 12ms ✅ (60fps)
Frame 2: 14ms ✅ (60fps)
Frame 3: 22ms ❌ (45fps) ← 프레임 드롭!
Frame 4: 13ms ✅ (60fps)

평균: 15.25ms → 약 55fps
```

### 최적화 전후 비교

**최적화 전**:
```
AsyncImage 기본 사용
├─ 네트워크: 200ms/image
├─ 디코딩: 80ms/image
└─ 총: 280ms/image

스크롤 시:
- FPS: 45-50 (끊김)
- CPU: 80-90% (높음)
```

**최적화 후** (캐싱 + 프리패칭):
```
캐시된 이미지 사용
├─ 캐시 히트: 5ms/image
├─ 디코딩: 0ms (캐시됨)
└─ 총: 5ms/image (56배 빠름!)

스크롤 시:
- FPS: 55-60 (부드러움)
- CPU: 20-30% (낮음)
```

---

## Allocations (메모리)

### 목적

- 메모리 사용량 측정
- 메모리 누수 탐지
- 메모리 증가 패턴 분석

### 실행 단계

#### 1단계: Allocations 시작

```
1. Xcode에서 ⌘I
2. "Allocations" 선택
3. Record 버튼 클릭 ●
```

#### 2단계: 메모리 측정

```
시나리오: 100개 이미지 로드

1. 앱 시작 (초기 메모리 확인)
2. 이미지 리스트 로드
3. 끝까지 스크롤
4. 다시 처음으로
5. 리스트 새로고침
6. Stop ⏹
```

#### 3단계: 메모리 그래프 분석

**Timeline**:
```
Memory Usage
250MB│              ┌─┐
     │             ││││
200MB│            ┌┘│││  ← 스크롤 중 피크
     │           ││ │││
150MB│     ┌────┬┘│ └┘│
     │    ││    │ │   │
100MB│ ┌─┐││    │ │   └─┐
     │ │ ││││    │ │     │
 50MB│─┴─┴┴┴┴────┴─┴─────┴──
     0s 5s 10s 15s 20s 25s 30s
     │  │   │    │  │    │
   시작 로드 스크롤 재로드 정리
```

#### 4단계: 메모리 상세 분석

**Statistics 탭**:
```
Category              Live Bytes  Live Count
──────────────────────────────────────────
All Heap Allocations      180MB      45000
├─ Images                 120MB        100  ← 대부분 이미지
├─ Swift Objects           40MB      44000
└─ Other                   20MB        900

Persistent Bytes: 180MB  ← 계속 유지되는 메모리
Transient Bytes: 50MB    ← 임시 메모리
```

**Call Tree**:
```
Allocation Type          Size     Count
─────────────────────────────────────
UIImage                  120MB      100
├─ CGImage.create()      100MB      100
├─ Image buffer           15MB      100
└─ Metadata                5MB      100

NSCache                   80MB    (cache)
├─ Cached Images          75MB       75
└─ Cache overhead          5MB        -
```

#### 5단계: 메모리 누수 확인

**Mark Generation**:
```
1. 앱 시작 → Mark Generation (M)
2. 이미지 로드 → Mark Generation (M)
3. 뒤로가기 → Mark Generation (M)
4. 다시 로드 → Mark Generation (M)

각 Generation의 메모리 증가 확인:
Generation A: 80MB (시작)
Generation B: 180MB (+100MB) ← 이미지 로드
Generation C: 85MB (-95MB) ← 정상 해제 ✅
Generation D: 185MB (+100MB) ← 다시 로드

메모리 누수 없음! ✅
```

**누수 예시**:
```
Generation C: 180MB (그대로) ← 메모리 미해제 ❌
→ 메모리 누수 의심!
→ Leaks 도구로 추가 분석 필요
```

---

## Network (네트워크)

### 목적

- 네트워크 요청 횟수 측정
- 다운로드/업로드 크기 확인
- 요청 시간 분석

### 실행 단계

#### 1단계: Network 프로파일 시작

```
1. Xcode에서 ⌘I
2. "Network" 선택
3. Record ●
```

#### 2단계: 네트워크 활동 기록

```
시나리오: 100개 이미지 다운로드

1. 앱 시작
2. 이미지 리스트 로드
3. 스크롤 (모든 이미지 표시)
4. Stop ⏹
```

#### 3단계: 네트워크 요청 분석

**Timeline**:
```
Network Activity
10MB/s│ ███
      │ ███████
 5MB/s│ ████████████    ← 이미지 다운로드
      │ ████████████████
 0MB/s│─────────────────────────
      0s  5s  10s  15s  20s
```

**Connections 테이블**:
```
URL                          Status  Size     Time    Count
───────────────────────────────────────────────────────────
picsum.photos/400/400?1       200    45KB    120ms     1
picsum.photos/400/400?2       200    48KB    135ms     1
picsum.photos/400/400?3       200    42KB    115ms     1
...
───────────────────────────────────────────────────────────
Total                                 4.5MB   12s      100

평균 요청 시간: 120ms
평균 이미지 크기: 45KB
총 다운로드: 4.5MB
```

#### 4단계: 캐시 효율 확인

**첫 로드**:
```
요청 수: 100
총 크기: 4.5MB
캐시 히트: 0%
```

**재로드** (캐시 적용):
```
요청 수: 0  ← 모든 요청이 캐시됨!
총 크기: 0MB
캐시 히트: 100% ✅
```

### 네트워크 최적화 효과

**최적화 전** (기본):
```
100개 이미지:
├─ 네트워크 요청: 100회
├─ 총 다운로드: 4.5MB
├─ 총 시간: 12초
└─ 데이터 비용: 4.5MB

재로드:
└─ 또 다시 4.5MB 다운로드 ❌
```

**최적화 후** (캐싱):
```
100개 이미지:
├─ 네트워크 요청: 100회 (첫 번째만)
├─ 총 다운로드: 4.5MB (첫 번째만)
├─ 총 시간: 12초 (첫 번째만)
└─ 데이터 비용: 4.5MB (첫 번째만)

재로드:
├─ 네트워크 요청: 0회 ✅
├─ 총 다운로드: 0MB ✅
├─ 총 시간: 0.5초 (24배 빠름!)
└─ 데이터 비용: 0MB ✅
```

---

## 실전 시나리오

### 시나리오 1: 스크롤 성능 측정

**목표**: LazyVStack 스크롤이 부드러운지 확인

#### 측정 방법

1. **Time Profiler** 실행 (⌘I)
2. 1000개 이미지 리스트 로드
3. 10초 동안 빠르게 스크롤
4. 결과 분석

#### 분석 기준

```
FPS 측정:
60fps = 16.67ms/frame ✅ 목표
55fps = 18.18ms/frame ✅ 양호
50fps = 20.00ms/frame ⚠️ 주의
45fps = 22.22ms/frame ❌ 개선 필요
```

#### 해석

**좋은 결과**:
```
평균 프레임 타임: 15ms
→ 약 66fps
→ 부드러운 스크롤 ✅
```

**나쁜 결과**:
```
평균 프레임 타임: 25ms
→ 약 40fps
→ 끊김 현상 ❌

병목 지점:
- Image.decode(): 15ms (60%)
→ 해결: 다운샘플링
```

---

### 시나리오 2: 메모리 누수 탐지

**목표**: 이미지 로드/언로드 시 메모리 누수 확인

#### 측정 방법

1. **Allocations** 실행 (⌘I)
2. 다음 패턴 반복 (5회):
   - 이미지 리스트 열기
   - 스크롤
   - 뒤로가기
3. 각 사이클마다 Mark Generation (M)
4. 메모리 증가 패턴 확인

#### 분석 기준

```
정상 패턴:
Gen 1: 80MB   (시작)
Gen 2: 180MB  (로드, +100MB)
Gen 3: 85MB   (해제, -95MB) ✅
Gen 4: 185MB  (재로드, +100MB)
Gen 5: 90MB   (해제, -95MB) ✅

메모리 누수 패턴:
Gen 1: 80MB   (시작)
Gen 2: 180MB  (로드, +100MB)
Gen 3: 180MB  (해제 안됨!) ❌
Gen 4: 280MB  (재로드, +100MB)
Gen 5: 280MB  (해제 안됨!) ❌

→ 매 사이클마다 100MB씩 누적
→ 메모리 누수 확실!
```

#### 해결 방법

```swift
// ❌ 메모리 누수 원인
class ImageLoader: ObservableObject {
    var images: [UIImage] = []
    
    func load() {
        // images 배열이 계속 쌓임
    }
    // deinit이 호출되지 않음 → 메모리 누수
}

// ✅ 수정
class ImageLoader: ObservableObject {
    var images: [UIImage] = []
    
    func load() {
        images.removeAll() // 이전 이미지 제거
    }
    
    deinit {
        images.removeAll()
        print("ImageLoader deinitialized") ← 확인
    }
}
```

---

### 시나리오 3: 네트워크 비용 측정

**목표**: 데이터 사용량 확인 및 최적화

#### 측정 방법

1. **Network** 실행 (⌘I)
2. 100개 이미지 리스트 로드
3. 재로드 3회
4. 총 다운로드 크기 확인

#### 분석

**캐싱 없음**:
```
첫 로드: 4.5MB
재로드 1: 4.5MB
재로드 2: 4.5MB
재로드 3: 4.5MB
───────────────
총: 18MB ❌

사용자 데이터 비용: 높음
로딩 시간: 느림
```

**캐싱 적용**:
```
첫 로드: 4.5MB
재로드 1: 0MB (캐시)
재로드 2: 0MB (캐시)
재로드 3: 0MB (캐시)
───────────────
총: 4.5MB ✅

절감: 75% (13.5MB)
로딩 시간: 빠름
```

---

## 성능 분석 팁

### 1. Release 모드에서 측정

```
⚠️ 중요: Debug 모드는 최적화가 꺼져 있어 부정확합니다!

Profile (⌘I)은 자동으로 Release 모드로 빌드합니다.
```

### 2. 실제 기기에서 테스트

```
시뮬레이터 vs 실제 기기:

시뮬레이터:
- Mac CPU 사용 (훨씬 빠름)
- 메모리 제약 없음
- 네트워크 지연 없음
→ 비현실적 결과 ❌

실제 기기:
- 실제 성능 반영
- 메모리 제약 존재
- 실제 네트워크 환경
→ 정확한 결과 ✅
```

### 3. 여러 번 측정

```
한 번의 측정은 부정확할 수 있습니다.

권장: 최소 3회 측정 후 평균 사용

측정 1: 55fps
측정 2: 58fps
측정 3: 56fps
───────────────
평균: 56.3fps ✅
```

### 4. 베이스라인 설정

```
최적화 전후 비교를 위해 베이스라인을 기록하세요:

Before:
- FPS: 45
- Memory: 250MB
- Network: 18MB

After:
- FPS: 58 (+29%)
- Memory: 180MB (-28%)
- Network: 4.5MB (-75%)

개선 효과가 명확히 보입니다! ✅
```

### 5. 목표 설정

```
성능 목표:
- FPS: 55+ (이상적으로 60)
- 메모리: 앱 전체 < 300MB
- 네트워크: 첫 로드만, 재로드 0MB
- 로딩 시간: 이미지당 < 150ms

목표를 달성할 때까지 최적화 반복
```

---

## 💡 핵심 정리

### Instruments 도구별 용도

| 도구 | 용도 | 측정 항목 | 목표 |
|------|------|-----------|------|
| **Time Profiler** | CPU, 프레임 | ms/frame | < 16.67ms |
| **Allocations** | 메모리 | MB | < 300MB |
| **Network** | 네트워크 | 요청, MB | 최소화 |
| **Leaks** | 메모리 누수 | 누수 횟수 | 0 |

### 측정 체크리스트

#### 실행 전
- [ ] Release 모드 확인 (⌘I 사용)
- [ ] 실제 기기 연결 (권장)
- [ ] 측정 시나리오 준비

#### 실행 중
- [ ] 일관된 동작 수행
- [ ] 충분한 시간 측정 (최소 10초)
- [ ] Mark Generation 활용

#### 실행 후
- [ ] 그래프 패턴 확인
- [ ] 병목 지점 파악
- [ ] 개선 방안 도출
- [ ] 최적화 후 재측정

### 최적화 우선순위

1. **FPS** (사용자 경험 직결)
   - 목표: 55+ fps
   - 방법: 이미지 다운샘플링, 캐싱

2. **메모리** (안정성)
   - 목표: < 300MB
   - 방법: LazyVStack, 캐시 제한

3. **네트워크** (데이터 비용)
   - 목표: 재로드 0MB
   - 방법: 캐싱, CDN

---

**Instruments = 성능 최적화의 필수 도구!** 🔍


