# Day 10: 이미지 캐싱 전략

> Kingfisher와 Nuke의 캐시 API를 활용하여 대용량 이미지 갤러리에 최적화된 캐싱 전략을 구현하고 실험합니다

---

## 📚 학습 목표

### 핵심 목표
- **캐시 이해**: 메모리 캐시와 디스크 캐시의 동작 원리
- **라이브러리 활용**: Kingfisher와 Nuke의 캐시 API 마스터
- **성능 최적화**: 캐시 히트율 향상과 메모리 효율 극대화
- **실전 전략**: 프로젝트 특성에 맞는 캐시 정책 설계

### 학습 포인트

#### 1. 캐시 계층
- **Level 1: 메모리 캐시** - 가장 빠름 (1-5ms)
- **Level 2: 디스크 캐시** - 중간 속도 (10-100ms)
- **Level 3: 네트워크** - 가장 느림 (200-5000ms)

#### 2. 캐시 정책
- **LRU**: Least Recently Used (가장 오래 사용 안 한 항목 삭제)
- **TTL**: Time To Live (시간 기반 만료)
- **용량 제한**: Cost + Count 기반

#### 3. 성능 최적화
- 프리페칭 (Prefetching)
- 다운샘플링 (Downsampling)
- 적응형 캐시 크기

---

## 🗂️ 파일 구조

```
day10/
├── README.md                       # 이 파일
├── 시작하기.md                     # 빠른 시작 가이드
│
├── CACHE_THEORY.md                # 캐싱 이론
├── CACHE_STRATEGY.md              # 캐시 전략
├── LIBRARY_CACHE_COMPARISON.md    # 라이브러리 비교
├── PERFORMANCE_GUIDE.md           # 성능 최적화
│
└── day10/
    ├── ContentView.swift          # 4개 탭 메인 뷰
    │
    ├── Core/                      # 캐시 관리
    │   ├── CacheConfiguration.swift      # 캐시 설정 모델
    │   ├── KingfisherCacheManager.swift  # Kingfisher 캐시 관리
    │   └── NukeCacheManager.swift        # Nuke 캐시 관리
    │
    ├── Views/                     # UI 뷰
    │   ├── KingfisherGalleryView.swift   # Kingfisher 갤러리
    │   ├── NukeGalleryView.swift         # Nuke 갤러리
    │   ├── CacheMonitorView.swift        # 캐시 모니터
    │   └── CacheSettingsView.swift       # 캐시 설정
    │
    └── tool/                      # 분석 도구
        ├── CacheAnalyzer.swift           # 캐시 분석
        ├── MemorySampler.swift           # 메모리 측정
        ├── DiskMonitor.swift             # 디스크 모니터
        └── PerformanceLogger.swift       # 성능 로깅
```

---

## 🚀 시작하기

### 1. 프로젝트 열기
```bash
cd day10
open day10.xcodeproj
```

### 2. 패키지 다운로드
첫 빌드 시 자동으로 Kingfisher와 Nuke가 다운로드됩니다.

### 3. 앱 실행
```
⌘R (Run)
```

### 4. 네트워크 연결 필요
이 프로젝트는 인터넷 연결이 필요합니다 (Picsum Photos API 사용).

---

## 📱 앱 구조

### Tab 1: Kingfisher 갤러리

**기능**:
- 100개 이미지 그리드 로딩
- 실시간 캐시 통계 표시
- 메모리/디스크 캐시 사용량 모니터링
- 캐시 히트율 추적

**컨트롤**:
- 이미지 개수 선택 (50/100/200)
- 다시 로드
- 캐시 삭제
- 통계 초기화

---

### Tab 2: Nuke 갤러리

**기능**:
- 100개 이미지 그리드 로딩
- Kingfisher와 동일한 통계 추적
- **프리히팅** 기능 (독점)
- 실시간 성능 비교

**프리히팅**:
- 이미지를 미리 로드하여 캐시에 저장
- 스크롤 시 즉각적인 표시
- 히트율 크게 향상

---

### Tab 3: 캐시 모니터

**4개 탭**:

#### Kingfisher 모니터
- 메모리/디스크 사용량
- 히트율 세부 정보 (메모리/디스크/미스)
- 캐시 관리 버튼
- 요약 정보

#### Nuke 모니터
- Kingfisher와 동일한 UI
- Nuke 캐시 상태 실시간 표시

#### 시스템 모니터
- 전체 메모리 사용량
- 디스크 사용량
- 캐시 디렉토리 크기
- 디스크 공간 부족 경고

#### 비교 뷰
- Kingfisher vs Nuke 비교
- 히트율 비교
- 메모리 효율 비교
- 디스크 효율 비교

---

### Tab 4: 캐시 설정

**설정 항목**:

#### 라이브러리 선택
- Kingfisher
- Nuke

#### 프리셋
- **최소** (30MB / 100MB): 저사양 기기
- **균형** (100MB / 500MB): 일반 사용 (권장)
- **공격적** (200MB / 1GB): 고성능 기기
- **커스텀**: 사용자 정의

#### 커스텀 설정 (프리셋: 커스텀 선택 시)
- 메모리 캐시 크기 (10-300MB)
- 디스크 캐시 크기 (50-2000MB)
- 이미지 개수 제한 (10-500개)
- TTL (5분/1시간/1일/7일/무제한)

#### 고급 옵션
- 자동 정리
- 메모리 경고 시 삭제
- 백그라운드 시 메모리 정리

---

## 🎯 실전 사용 시나리오

### 시나리오 1: 캐시 효과 체험

1. **Kingfisher 갤러리** 탭으로 이동
2. "이미지 개수" → 100개 선택
3. 앱 실행 → 첫 로드 관찰 (약 30초)
4. **"다시 로드"** 클릭 → 즉시 표시! (약 0.5초)
5. 히트율 확인 → 90%+ 예상

**결과**: 캐시로 **60배 빠른** 재로드 체험

---

### 시나리오 2: Kingfisher vs Nuke 비교

1. **Kingfisher 갤러리** → 100개 로드 → 통계 확인
2. **Nuke 갤러리** → 100개 로드 → 통계 확인
3. **캐시 모니터** → **비교** 탭
4. 성능 비교 분석

**예상 결과**:
- Nuke가 약간 더 빠른 로딩
- Nuke가 메모리 효율 더 좋음
- 히트율은 비슷 (95%+)

---

### 시나리오 3: 프리히팅 효과 테스트

1. **Nuke 갤러리** 탭
2. **"캐시 삭제"** 클릭 (초기화)
3. **"프리히팅"** 클릭 → 3초 대기
4. 스크롤 → 모든 이미지 즉시 표시
5. 히트율 → 99-100%

**결과**: 프리히팅으로 **완벽한 UX**

---

### 시나리오 4: 캐시 정책 실험

#### 실험 1: 메모리 부족 시나리오

1. **캐시 설정** → **커스텀**
2. 메모리 캐시: **10MB** (매우 작게)
3. 설정 적용
4. **Kingfisher 갤러리** → 200개 로드
5. **캐시 모니터** 관찰

**예상 결과**:
- 메모리 캐시 금방 가득
- LRU로 오래된 이미지 자동 삭제
- 디스크 캐시로 폴백

#### 실험 2: TTL 만료 테스트

1. **캐시 설정** → **커스텀**
2. TTL: **5분**
3. 설정 적용
4. 이미지 로드
5. 5분 후 다시 로드

**예상 결과**:
- 5분 전: 캐시 히트 (즉시 표시)
- 5분 후: 캐시 미스 (다시 다운로드)

---

## 📊 성능 벤치마크

### 테스트 환경
- 기기: iPhone 시뮬레이터
- 네트워크: Wi-Fi
- 이미지: 100개 (각 300×300)

### 결과

| 시나리오 | 첫 로드 | 재로드 (메모리) | 재로드 (디스크) | 히트율 |
|----------|---------|----------------|----------------|--------|
| **Kingfisher** | 28초 | 0.4초 | 3.5초 | 95% |
| **Nuke** | 26초 | 0.3초 | 2.8초 | 97% |
| **Nuke + 프리히팅** | 26초 | 0.2초 | - | 99% |

**결론**:
- Nuke가 약 7% 빠름
- 프리히팅으로 히트율 99%+ 달성
- 재로드 시 **70배 빠름**

---

## 💡 핵심 학습 포인트

### 1. 캐시 계층 이해

```
메모리 캐시 (NSCache)
├─ 속도: ⚡⚡⚡ 1-5ms
├─ 용량: 50-200MB
└─ 지속: 앱 실행 중

디스크 캐시 (FileManager)
├─ 속도: ⚡⚡ 10-100ms
├─ 용량: 100MB-1GB
└─ 지속: 영구

네트워크
├─ 속도: ⚡ 200-5000ms
├─ 용량: 무제한
└─ 비용: 데이터 요금
```

### 2. 라이브러리 선택

**Kingfisher**:
- ✅ 간편한 API
- ✅ SwiftUI 통합 우수
- ✅ 중소 규모 앱 권장

**Nuke**:
- ✅ 최고 성능
- ✅ 메모리 효율
- ✅ 대용량 이미지 앱 권장

### 3. 성능 최적화

**필수**:
- 적절한 캐시 크기 설정
- 메모리 경고 처리
- 2단계 캐싱 (메모리 + 디스크)

**권장**:
- 프리페칭 구현
- 다운샘플링 적용
- 캐시 통계 추적

**고급**:
- 적응형 캐시 크기
- 우선순위 기반 캐싱
- TTL 정책 최적화

---

## 🎓 학습 체크리스트

### 기본
- [ ] 캐시 계층 구조 이해 (메모리/디스크/네트워크)
- [ ] NSCache 사용법 숙지
- [ ] LRU 동작 원리 이해
- [ ] 캐시 히트/미스 개념 이해

### 응용
- [ ] Kingfisher 캐시 API 활용
- [ ] Nuke 캐시 API 활용
- [ ] 캐시 통계 추적
- [ ] 성능 비교 분석

### 심화
- [ ] 캐시 정책 설계
- [ ] 프리페칭 전략
- [ ] 메모리 최적화
- [ ] TTL 정책 설계

---

## 📖 참고 자료

### 이론 문서 (필수)
1. **CACHE_THEORY.md**: 캐싱 기본 개념
2. **CACHE_STRATEGY.md**: 캐시 정책 (LRU, TTL)
3. **LIBRARY_CACHE_COMPARISON.md**: 라이브러리 비교
4. **PERFORMANCE_GUIDE.md**: 성능 최적화

### 공식 문서
- [Kingfisher GitHub](https://github.com/onevcat/Kingfisher)
- [Nuke GitHub](https://github.com/kean/Nuke)
- [Apple: NSCache](https://developer.apple.com/documentation/foundation/nscache)
- [Apple: URLCache](https://developer.apple.com/documentation/foundation/urlcache)

### 이전 학습
- **Day 8**: URLSession 비동기 이미지 로딩
- **Day 9**: 라이브러리 비교 (SDWebImage/Kingfisher/Nuke)

---

## 🎯 다음 단계

Day 10을 완료했다면:

### 1. 실전 적용
- 자신의 프로젝트에 캐시 전략 적용
- 성능 비교 및 최적화
- 프로덕션 환경 테스트

### 2. 고급 기능
- 커스텀 캐시 정책 구현
- 오프라인 모드 지원
- 백그라운드 프리페칭

### 3. 최적화
- 메모리 사용량 최소화
- 배터리 소비 최적화
- 네트워크 트래픽 절감

---

## 💬 핵심 요약

### 캐시의 힘
- ⚡ **70배 빠른** 재로드
- 💰 **50% 데이터** 절감
- 🚀 **즉각적인** UX

### 라이브러리 선택
- **일반 앱**: Kingfisher (균형)
- **고성능 앱**: Nuke (속도)
- **레거시**: SDWebImage (안정성)

### 최적화 전략
- 적절한 캐시 크기
- 프리페칭 활용
- 다운샘플링 적용
- 메모리 경고 대응

---

**Happy Caching! 🚀**

*효율적인 캐싱으로 최고의 사용자 경험을 제공하세요!*











