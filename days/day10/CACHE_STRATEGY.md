# ìºì‹œ ì „ëµ

> íš¨ìœ¨ì ì¸ ìºì‹œ ì •ì±… ì„¤ê³„: LRU, TTL, ìš©ëŸ‰ ê´€ë¦¬, ë¬´íš¨í™” ì „ëµ

---

## ğŸ“š ìºì‹œ ì •ì±…ì´ë€?

**ìºì‹œ ì •ì±…(Cache Policy)**ì€ ë‹¤ìŒ ì§ˆë¬¸ë“¤ì— ëŒ€í•œ ë‹µì…ë‹ˆë‹¤:

1. **ì–´ë–¤ ë°ì´í„°ë¥¼ ìºì‹±í• ê¹Œ?** (ì„ íƒ ì •ì±…)
2. **ì–¼ë§ˆë‚˜ ì˜¤ë˜ ë³´ê´€í• ê¹Œ?** (ë§Œë£Œ ì •ì±…)
3. **ì–¸ì œ ì‚­ì œí• ê¹Œ?** (êµì²´ ì •ì±…)
4. **ì–¼ë§ˆë‚˜ ì €ì¥í• ê¹Œ?** (ìš©ëŸ‰ ì •ì±…)

---

## ğŸ”„ ìºì‹œ êµì²´ ì •ì±… (Eviction Policy)

ìºì‹œê°€ ê°€ë“ ì°¼ì„ ë•Œ **ì–´ë–¤ í•­ëª©ì„ ì‚­ì œ**í• ì§€ ê²°ì •í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ì…ë‹ˆë‹¤.

### 1. LRU (Least Recently Used)

**ê°€ì¥ ì˜¤ë˜ ì‚¬ìš©ë˜ì§€ ì•Šì€** í•­ëª©ì„ ì‚­ì œí•©ë‹ˆë‹¤.

```
ì‹œê°„ íë¦„ â†’
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. ìºì‹œ: [A, B, C, D, E]  (ìš©ëŸ‰ ê°€ë“)

2. F ì¶”ê°€ í•„ìš”
   â†’ Aê°€ ê°€ì¥ ì˜¤ë˜ ì‚¬ìš© ì•ˆ ë¨
   â†’ A ì‚­ì œ
   ìºì‹œ: [B, C, D, E, F]

3. B ì ‘ê·¼ (ì½ê¸°)
   â†’ Bê°€ ìµœì‹ ìœ¼ë¡œ ì´ë™
   ìºì‹œ: [C, D, E, F, B]

4. G ì¶”ê°€ í•„ìš”
   â†’ Cê°€ ê°€ì¥ ì˜¤ë˜ ì‚¬ìš© ì•ˆ ë¨
   â†’ C ì‚­ì œ
   ìºì‹œ: [D, E, F, B, G]
```

**ì¥ì **:
- âœ… ì‹œê°„ ì§€ì—­ì„±(Temporal Locality) í™œìš©
- âœ… ìµœê·¼ ì‚¬ìš©í•œ ë°ì´í„°ëŠ” ê³§ ë‹¤ì‹œ ì‚¬ìš© ê°€ëŠ¥ì„± ë†’ìŒ
- âœ… ì‹¤ì „ì—ì„œ ê°€ì¥ íš¨ê³¼ì 

**ë‹¨ì **:
- âŒ êµ¬í˜„ ë³µì¡ë„ ë†’ìŒ (Double Linked List + HashMap)
- âŒ ì ‘ê·¼í•  ë•Œë§ˆë‹¤ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ í•„ìš”

**iOSì—ì„œ**:
- NSCacheê°€ **ìë™ìœ¼ë¡œ LRU ì‚¬ìš©**
- Kingfisher, Nuke ëª¨ë‘ LRU ê¸°ë°˜

---

### 2. FIFO (First In First Out)

**ê°€ì¥ ë¨¼ì € ë“¤ì–´ì˜¨** í•­ëª©ì„ ì‚­ì œí•©ë‹ˆë‹¤.

```
ì‹œê°„ íë¦„ â†’
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1. ìºì‹œ: [A, B, C, D, E]  (ìˆœì„œëŒ€ë¡œ ì¶”ê°€ë¨)

2. F ì¶”ê°€ í•„ìš”
   â†’ Aê°€ ê°€ì¥ ë¨¼ì € ì¶”ê°€ë¨
   â†’ A ì‚­ì œ
   ìºì‹œ: [B, C, D, E, F]

3. B ì ‘ê·¼ (ì½ê¸°)
   â†’ ìˆœì„œ ë³€ê²½ ì—†ìŒ!
   ìºì‹œ: [B, C, D, E, F]

4. G ì¶”ê°€ í•„ìš”
   â†’ Bê°€ ê°€ì¥ ì˜¤ë˜ë¨ (ì ‘ê·¼ ë¬´ê´€)
   â†’ B ì‚­ì œ
   ìºì‹œ: [C, D, E, F, G]
```

**ì¥ì **:
- âœ… êµ¬í˜„ ê°„ë‹¨ (Queue)
- âœ… ì˜ˆì¸¡ ê°€ëŠ¥
- âœ… ì˜¤ë²„í—¤ë“œ ë‚®ìŒ

**ë‹¨ì **:
- âŒ ìì£¼ ì‚¬ìš©ë˜ëŠ” í•­ëª©ë„ ì‚­ì œë¨
- âŒ ìºì‹œ íš¨ìœ¨ ë‚®ìŒ

**ì‚¬ìš© ì¼€ì´ìŠ¤**:
- ìŠ¤íŠ¸ë¦¬ë° ë°ì´í„°
- ìˆœì°¨ì  ì²˜ë¦¬

---

### 3. LFU (Least Frequently Used)

**ì‚¬ìš© ë¹ˆë„ê°€ ê°€ì¥ ë‚®ì€** í•­ëª©ì„ ì‚­ì œí•©ë‹ˆë‹¤.

```
ì‹œê°„ íë¦„ â†’
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ìºì‹œ: [A(5íšŒ), B(3íšŒ), C(8íšŒ), D(2íšŒ), E(4íšŒ)]

F ì¶”ê°€ í•„ìš”
â†’ Dê°€ ì‚¬ìš© ë¹ˆë„ ê°€ì¥ ë‚®ìŒ (2íšŒ)
â†’ D ì‚­ì œ
ìºì‹œ: [A(5íšŒ), B(3íšŒ), C(8íšŒ), E(4íšŒ), F(1íšŒ)]

A ì ‘ê·¼ â†’ A(6íšŒ)
B ì ‘ê·¼ â†’ B(4íšŒ)

G ì¶”ê°€ í•„ìš”
â†’ Fê°€ ì‚¬ìš© ë¹ˆë„ ê°€ì¥ ë‚®ìŒ (1íšŒ)
â†’ F ì‚­ì œ
ìºì‹œ: [A(6íšŒ), B(4íšŒ), C(8íšŒ), E(4íšŒ), G(1íšŒ)]
```

**ì¥ì **:
- âœ… ìì£¼ ì‚¬ìš©ë˜ëŠ” í•­ëª© ë³´í˜¸
- âœ… ë¹ˆë„ ê¸°ë°˜ ì˜ˆì¸¡

**ë‹¨ì **:
- âŒ ìµœê·¼ì„± ë¬´ì‹œ (ì˜¤ë˜ì „ ìì£¼ ì‚¬ìš©í•œ í•­ëª©ì´ ë‚¨ìŒ)
- âŒ ìƒˆ í•­ëª© ë¶ˆë¦¬ (ë¹ˆë„ ë‚®ìŒ)
- âŒ ì¹´ìš´í„° ì˜¤ë²„í—¤ë“œ

**ì‚¬ìš© ì¼€ì´ìŠ¤**:
- ì¥ê¸°ê°„ íŒ¨í„´ ë¶„ì„
- ì¸ê¸° ì½˜í…ì¸  ìºì‹±

---

### 4. Random

**ë¬´ì‘ìœ„ë¡œ** í•­ëª©ì„ ì‚­ì œí•©ë‹ˆë‹¤.

**ì¥ì **:
- âœ… êµ¬í˜„ ê°€ì¥ ê°„ë‹¨
- âœ… ì˜¤ë²„í—¤ë“œ ìµœì†Œ

**ë‹¨ì **:
- âŒ ì˜ˆì¸¡ ë¶ˆê°€
- âŒ íš¨ìœ¨ ë‚®ìŒ

**ì‚¬ìš© ì¼€ì´ìŠ¤**:
- í”„ë¡œí† íƒ€ì…
- ê°„ë‹¨í•œ ìºì‹œ

---

## â° TTL (Time To Live) ì „ëµ

ìºì‹œ í•­ëª©ì˜ **ìœ íš¨ ê¸°ê°„**ì„ ì„¤ì •í•©ë‹ˆë‹¤.

### TTL ê°œë…

```
ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ â†’ ìºì‹œ ì €ì¥ (íƒ€ì„ìŠ¤íƒ¬í”„ ê¸°ë¡)
        â†“
    ì‹œê°„ ê²½ê³¼
        â†“
TTL ê²½ê³¼? â”€â”€YESâ”€â”€â†’ ìºì‹œ ë¬´íš¨í™” (ë‹¤ì‹œ ë‹¤ìš´ë¡œë“œ)
    â”‚
    NO
    â†“
ìºì‹œì—ì„œ ë°˜í™˜
```

### TTL ì„¤ì • ì˜ˆì‹œ

```swift
struct CachedItem {
    let image: UIImage
    let timestamp: Date
    let ttl: TimeInterval
    
    var isExpired: Bool {
        Date().timeIntervalSince(timestamp) > ttl
    }
}

class TTLCache {
    private var cache = [String: CachedItem]()
    
    func store(_ image: UIImage, forKey key: String, ttl: TimeInterval) {
        cache[key] = CachedItem(
            image: image,
            timestamp: Date(),
            ttl: ttl
        )
    }
    
    func retrieve(forKey key: String) -> UIImage? {
        guard let item = cache[key] else { return nil }
        
        // ë§Œë£Œ í™•ì¸
        if item.isExpired {
            cache.removeValue(forKey: key)
            print("â° TTL ë§Œë£Œ: \(key)")
            return nil
        }
        
        return item.image
    }
}
```

### TTL ì„¤ì • ê°€ì´ë“œ

| ì½˜í…ì¸  íƒ€ì… | TTL | ì´ìœ  |
|-----------|-----|------|
| **í”„ë¡œí•„ ì‚¬ì§„** | 1ì¼ | ìì£¼ ë³€ê²½ë˜ì§€ ì•ŠìŒ |
| **ë‰´ìŠ¤ ì´ë¯¸ì§€** | 1ì‹œê°„ | ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ |
| **ê´‘ê³  ë°°ë„ˆ** | 5ë¶„ | ë¹ˆë²ˆí•œ êµì²´ |
| **ìƒí’ˆ ì´ë¯¸ì§€** | 1ì£¼ì¼ | ì•ˆì •ì  |
| **ì•„ì´ì½˜** | ë¬´ì œí•œ | ë³€ê²½ ì—†ìŒ |

---

## ğŸ’¾ ìš©ëŸ‰ ì œí•œ ì „ëµ

### 1. Cost ê¸°ë°˜ ì œí•œ

ì´ë¯¸ì§€ì˜ **ë©”ëª¨ë¦¬ í¬ê¸°**ë¥¼ ë¹„ìš©ìœ¼ë¡œ ê³„ì‚°í•©ë‹ˆë‹¤.

```swift
let cache = NSCache<NSString, UIImage>()

// ìµœëŒ€ 100MB
cache.totalCostLimit = 100 * 1024 * 1024

// ì´ë¯¸ì§€ ì €ì¥ ì‹œ cost ê³„ì‚°
func store(_ image: UIImage, forKey key: String) {
    // RGBA: 4 bytes per pixel
    let cost = Int(image.size.width * image.size.height * 4)
    cache.setObject(image, forKey: key as NSString, cost: cost)
}
```

**Cost ê³„ì‚° ì˜ˆì‹œ**:

```
ì´ë¯¸ì§€ 1: 800Ã—600 = 480,000 pixels Ã— 4 = 1.92 MB
ì´ë¯¸ì§€ 2: 1200Ã—800 = 960,000 pixels Ã— 4 = 3.84 MB
ì´ë¯¸ì§€ 3: 400Ã—300 = 120,000 pixels Ã— 4 = 0.48 MB

ì´ Cost: 1.92 + 3.84 + 0.48 = 6.24 MB / 100 MB
```

### 2. Count ê¸°ë°˜ ì œí•œ

ì´ë¯¸ì§€ **ê°œìˆ˜**ë¡œ ì œí•œí•©ë‹ˆë‹¤.

```swift
cache.countLimit = 50  // ìµœëŒ€ 50ê°œ

// ì¥ì : ê°„ë‹¨, ì˜ˆì¸¡ ê°€ëŠ¥
// ë‹¨ì : í¬ê¸° ë¬´ì‹œ (í° ì´ë¯¸ì§€ 50ê°œ = ë©”ëª¨ë¦¬ ë¶€ì¡± ê°€ëŠ¥)
```

### 3. í•˜ì´ë¸Œë¦¬ë“œ ì „ëµ

**Cost + Count** ì¡°í•©

```swift
cache.totalCostLimit = 100 * 1024 * 1024  // 100MB
cache.countLimit = 100                     // ìµœëŒ€ 100ê°œ

// ë‘˜ ì¤‘ í•˜ë‚˜ë¼ë„ ì´ˆê³¼í•˜ë©´ ì‚­ì œ ì‹œì‘
```

---

## ğŸ¯ ìºì‹œ ë¬´íš¨í™” ì „ëµ

### 1. ìˆ˜ë™ ë¬´íš¨í™”

ëª…ì‹œì ìœ¼ë¡œ ìºì‹œë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.

```swift
// íŠ¹ì • ì´ë¯¸ì§€ ì‚­ì œ
cache.removeImage(forKey: "profile-image")

// ì „ì²´ ì‚­ì œ
cache.clearAll()

// ì¡°ê±´ë¶€ ì‚­ì œ
cache.removeIf { image in
    image.timestamp < Date().addingTimeInterval(-3600) // 1ì‹œê°„ ì´ìƒ ëœ í•­ëª©
}
```

### 2. ìë™ ë¬´íš¨í™”

ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ì— ë°˜ì‘í•©ë‹ˆë‹¤.

```swift
// ë©”ëª¨ë¦¬ ê²½ê³ 
NotificationCenter.default.addObserver(
    forName: UIApplication.didReceiveMemoryWarningNotification,
    object: nil,
    queue: .main
) { _ in
    cache.clearMemoryCache()  // ë©”ëª¨ë¦¬ ìºì‹œë§Œ ì‚­ì œ
}

// ë°±ê·¸ë¼ìš´ë“œ ì§„ì…
NotificationCenter.default.addObserver(
    forName: UIApplication.didEnterBackgroundNotification,
    object: nil,
    queue: .main
) { _ in
    cache.cleanupOldItems()  // ì˜¤ë˜ëœ í•­ëª© ì •ë¦¬
}

// ì•± ì¢…ë£Œ
NotificationCenter.default.addObserver(
    forName: UIApplication.willTerminateNotification,
    object: nil,
    queue: .main
) { _ in
    cache.persistToDisk()  // ë””ìŠ¤í¬ì— ì €ì¥
}
```

### 3. ETag ê¸°ë°˜ ë¬´íš¨í™”

ì„œë²„ê°€ ì œê³µí•˜ëŠ” **ETag**(ì—”í‹°í‹° íƒœê·¸)ë¥¼ í™œìš©í•©ë‹ˆë‹¤.

```swift
struct CachedResponse {
    let image: UIImage
    let etag: String
}

func loadImage(from url: URL) async throws -> UIImage {
    // 1. ìºì‹œ í™•ì¸
    if let cached = cache[url.absoluteString] {
        // 2. ì„œë²„ì— ETag ì¬ê²€ì¦
        var request = URLRequest(url: url)
        request.addValue(cached.etag, forHTTPHeaderField: "If-None-Match")
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        // 3. 304 Not Modified â†’ ìºì‹œ ìœ íš¨
        if (response as? HTTPURLResponse)?.statusCode == 304 {
            return cached.image
        }
        
        // 4. 200 OK â†’ ìƒˆ ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ
        let newETag = (response as? HTTPURLResponse)?
            .value(forHTTPHeaderField: "ETag")
        // ìºì‹œ ì—…ë°ì´íŠ¸...
    }
    
    // ìºì‹œ ì—†ìŒ â†’ ë‹¤ìš´ë¡œë“œ
    // ...
}
```

---

## ğŸ—ï¸ ì‹¤ì „ ìºì‹œ ì •ì±… ì„¤ê³„

### ì‹œë‚˜ë¦¬ì˜¤ 1: ì†Œì…œ ë¯¸ë””ì–´ ì•±

```swift
struct SocialMediaCachePolicy {
    // ë©”ëª¨ë¦¬ ìºì‹œ
    let memoryLimit = 100 * 1024 * 1024  // 100MB
    let memoryCount = 100                 // 100ê°œ
    
    // ë””ìŠ¤í¬ ìºì‹œ
    let diskLimit = 500 * 1024 * 1024    // 500MB
    
    // TTL
    let profileImageTTL: TimeInterval = 86400      // 1ì¼
    let feedImageTTL: TimeInterval = 3600          // 1ì‹œê°„
    let storiesTTL: TimeInterval = 300             // 5ë¶„
    
    // êµì²´ ì •ì±…
    let evictionPolicy = "LRU"
}
```

**ì´ìœ **:
- í”¼ë“œ ìŠ¤í¬ë¡¤ ì‹œ ë¹ ë¥¸ ì‘ë‹µ í•„ìš” â†’ í° ë©”ëª¨ë¦¬ ìºì‹œ
- í”„ë¡œí•„ì€ ì•ˆì •ì  â†’ ê¸´ TTL
- ìŠ¤í† ë¦¬ëŠ” ì‹¤ì‹œê°„ â†’ ì§§ì€ TTL

---

### ì‹œë‚˜ë¦¬ì˜¤ 2: ì „ììƒê±°ë˜ ì•±

```swift
struct EcommerceCachePolicy {
    // ë©”ëª¨ë¦¬ ìºì‹œ
    let memoryLimit = 50 * 1024 * 1024   // 50MB (ì‘ê²Œ)
    let memoryCount = 50
    
    // ë””ìŠ¤í¬ ìºì‹œ
    let diskLimit = 1 * 1024 * 1024 * 1024  // 1GB (í¬ê²Œ)
    
    // TTL
    let productImageTTL: TimeInterval = 604800     // 7ì¼
    let bannerTTL: TimeInterval = 1800             // 30ë¶„
    
    // í”„ë¦¬í˜ì¹­
    let prefetchCount = 20  // ë‹¤ìŒ 20ê°œ ìƒí’ˆ ë¯¸ë¦¬ ë¡œë“œ
}
```

**ì´ìœ **:
- ìƒí’ˆ ì´ë¯¸ì§€ëŠ” ìì£¼ ë³€ê²½ ì•ˆ ë¨ â†’ ê¸´ TTL, í° ë””ìŠ¤í¬
- ë°°ë„ˆëŠ” ìì£¼ êµì²´ â†’ ì§§ì€ TTL
- ìŠ¤í¬ë¡¤ ì„±ëŠ¥ â†’ í”„ë¦¬í˜ì¹­

---

### ì‹œë‚˜ë¦¬ì˜¤ 3: ë‰´ìŠ¤ ì•±

```swift
struct NewsCachePolicy {
    // ë©”ëª¨ë¦¬ ìºì‹œ
    let memoryLimit = 30 * 1024 * 1024   // 30MB
    let memoryCount = 30
    
    // ë””ìŠ¤í¬ ìºì‹œ
    let diskLimit = 200 * 1024 * 1024    // 200MB
    
    // TTL
    let breakingNewsTTL: TimeInterval = 300        // 5ë¶„
    let articleImageTTL: TimeInterval = 3600       // 1ì‹œê°„
    let archiveTTL: TimeInterval = 86400           // 1ì¼
    
    // ìë™ ì •ë¦¬
    let cleanupInterval: TimeInterval = 3600       // 1ì‹œê°„ë§ˆë‹¤
}
```

**ì´ìœ **:
- ì†ë³´ëŠ” ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ â†’ ì§§ì€ TTL
- ë©”ëª¨ë¦¬ ì ˆì•½ (í…ìŠ¤íŠ¸ ì½˜í…ì¸  ìš°ì„ )
- ì •ê¸°ì  ì •ë¦¬ë¡œ ìµœì‹  ë‰´ìŠ¤ ìœ ì§€

---

## ğŸ“Š ìºì‹œ íˆíŠ¸ìœ¨ ìµœì í™”

### ìºì‹œ íˆíŠ¸ìœ¨ì´ë€?

```
íˆíŠ¸ìœ¨ = (ìºì‹œ íˆíŠ¸ ìˆ˜ / ì „ì²´ ìš”ì²­ ìˆ˜) Ã— 100%

ì˜ˆì‹œ:
ì´ ìš”ì²­: 1000íšŒ
ìºì‹œ íˆíŠ¸: 850íšŒ
íˆíŠ¸ìœ¨: 85%
```

### íˆíŠ¸ìœ¨ ëª©í‘œ

| íˆíŠ¸ìœ¨ | í‰ê°€ | ê°œì„  í•„ìš” |
|-------|-----|----------|
| **90%+** | ğŸŸ¢ ìš°ìˆ˜ | - |
| **70-90%** | ğŸŸ¡ ì–‘í˜¸ | í”„ë¦¬í˜ì¹­ ì¶”ê°€ |
| **50-70%** | ğŸŸ  ë³´í†µ | ìºì‹œ í¬ê¸° ì¦ê°€ |
| **50% ë¯¸ë§Œ** | ğŸ”´ ë‚˜ì¨ | ì „ëµ ì¬ê²€í†  |

### íˆíŠ¸ìœ¨ í–¥ìƒ ì „ëµ

#### 1. í”„ë¦¬í˜ì¹­ (Prefetching)

ë¯¸ë¦¬ ì´ë¯¸ì§€ë¥¼ ë¡œë“œí•©ë‹ˆë‹¤.

```swift
// í˜„ì¬ í™”ë©´: ì´ë¯¸ì§€ 1-10
// í”„ë¦¬í˜ì¹­: ì´ë¯¸ì§€ 11-20

func prefetchImages(from index: Int, count: Int) {
    let urls = (index..<index+count).map { imageURL(for: $0) }
    imagePrefetcher.startPrefetching(urls)
}

// ìŠ¤í¬ë¡¤ ì´ë²¤íŠ¸
func scrollViewDidScroll(_ scrollView: UIScrollView) {
    let visibleIndexes = getVisibleIndexes()
    let nextIndex = visibleIndexes.max() ?? 0
    prefetchImages(from: nextIndex + 1, count: 10)
}
```

#### 2. ì ì ˆí•œ ìºì‹œ í¬ê¸°

```swift
// âŒ ë„ˆë¬´ ì‘ìŒ
cache.totalCostLimit = 10 * 1024 * 1024  // 10MB
// â†’ ìì£¼ ì‚­ì œ â†’ íˆíŠ¸ìœ¨ ë‚®ìŒ

// âœ… ì ì ˆí•¨
cache.totalCostLimit = 100 * 1024 * 1024  // 100MB
// â†’ ì¶©ë¶„í•œ ë³´ê´€ â†’ íˆíŠ¸ìœ¨ ë†’ìŒ
```

#### 3. ë‹¤ìš´ìƒ˜í”Œë§

í° ì´ë¯¸ì§€ë¥¼ í•„ìš”í•œ í¬ê¸°ë¡œ ì¶•ì†Œí•©ë‹ˆë‹¤.

```swift
// âŒ ì›ë³¸ ê·¸ëŒ€ë¡œ (2000Ã—1500 = 12MB)
let image = UIImage(data: data)

// âœ… ë‹¤ìš´ìƒ˜í”Œë§ (200Ã—150 = 120KB)
let options = [
    kCGImageSourceCreateThumbnailWithTransform: true,
    kCGImageSourceCreateThumbnailFromImageAlways: true,
    kCGImageSourceThumbnailMaxPixelSize: 200
] as CFDictionary

// 100ë°° ë©”ëª¨ë¦¬ ì ˆì•½ â†’ ë” ë§ì€ ì´ë¯¸ì§€ ìºì‹± ê°€ëŠ¥
```

---

## ğŸ® ìºì‹œ ì •ì±… ì‹œë®¬ë ˆì´ì…˜

### ì˜ˆì œ: 100ê°œ ì´ë¯¸ì§€ ìŠ¤í¬ë¡¤

```
ì„¤ì •:
- ë©”ëª¨ë¦¬ ìºì‹œ: 20MB (ì•½ 20ê°œ ì´ë¯¸ì§€)
- ì´ë¯¸ì§€ í¬ê¸°: 1MB
- êµì²´ ì •ì±…: LRU

ì‹œë®¬ë ˆì´ì…˜:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1-20ë²ˆ ì´ë¯¸ì§€ ë¡œë“œ:
   ìºì‹œ íˆíŠ¸: 0/20 (0%)
   ìºì‹œ: [1...20] (ê°€ë“)

21ë²ˆ ì´ë¯¸ì§€ ë¡œë“œ:
   â†’ 1ë²ˆ ì‚­ì œ (ê°€ì¥ ì˜¤ë˜ë¨)
   ìºì‹œ íˆíŠ¸: 0/21 (0%)
   ìºì‹œ: [2...21]

...

40ë²ˆ ì´ë¯¸ì§€ ë¡œë“œ:
   ìºì‹œ íˆíŠ¸: 0/40 (0%)
   ìºì‹œ: [21...40]

ìœ„ë¡œ ìŠ¤í¬ë¡¤ â†’ 20ë²ˆ ì¬ë¡œë“œ:
   âœ… ìºì‹œ íˆíŠ¸! (20ë²ˆì´ ìºì‹œì— ìˆìŒ)
   ìºì‹œ íˆíŠ¸: 1/41 (2.4%)

...

100ë²ˆê¹Œì§€ ë¡œë“œ í›„ ì²˜ìŒìœ¼ë¡œ ëŒì•„ê°€ê¸°:
   10ë²ˆ ì¬ë¡œë“œ:
   âŒ ìºì‹œ ë¯¸ìŠ¤ (ì´ë¯¸ ì‚­ì œë¨)
   
ìµœì¢… íˆíŠ¸ìœ¨: ì•½ 20% (ë‚®ìŒ)
```

### ê°œì„ : ìºì‹œ í¬ê¸° ì¦ê°€

```
ì„¤ì •:
- ë©”ëª¨ë¦¬ ìºì‹œ: 100MB (100ê°œ ì´ë¯¸ì§€)

ì‹œë®¬ë ˆì´ì…˜:
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
1-100ë²ˆ ì´ë¯¸ì§€ ë¡œë“œ:
   ìºì‹œ íˆíŠ¸: 0/100 (0%)
   ìºì‹œ: [1...100] (ê°€ë“)

ìœ„ë¡œ ìŠ¤í¬ë¡¤ â†’ 50ë²ˆ ì¬ë¡œë“œ:
   âœ… ìºì‹œ íˆíŠ¸!

ë‹¤ì‹œ ì²˜ìŒìœ¼ë¡œ â†’ 10ë²ˆ ì¬ë¡œë“œ:
   âœ… ìºì‹œ íˆíŠ¸!

ìµœì¢… íˆíŠ¸ìœ¨: ì•½ 80% (ìš°ìˆ˜)
```

---

## ğŸ’¡ í•µì‹¬ ìš”ì•½

### êµì²´ ì •ì±…

1. **LRU**: ê°€ì¥ ì˜¤ë˜ ì‚¬ìš© ì•ˆ í•œ í•­ëª© ì‚­ì œ (ì¶”ì²œ)
2. **FIFO**: ë¨¼ì € ë“¤ì–´ì˜¨ í•­ëª© ì‚­ì œ (ê°„ë‹¨)
3. **LFU**: ì‚¬ìš© ë¹ˆë„ ë‚®ì€ í•­ëª© ì‚­ì œ (ë³µì¡)

### TTL ì „ëµ

- ìì£¼ ë³€ê²½: ì§§ì€ TTL (5ë¶„-1ì‹œê°„)
- ì•ˆì •ì : ê¸´ TTL (1ì¼-1ì£¼ì¼)
- ì •ì : ë¬´ì œí•œ TTL

### ìš©ëŸ‰ ì œí•œ

- Cost ê¸°ë°˜: ë©”ëª¨ë¦¬ í¬ê¸° ê³„ì‚° (ì •í™•)
- Count ê¸°ë°˜: ê°œìˆ˜ ì œí•œ (ê°„ë‹¨)
- í•˜ì´ë¸Œë¦¬ë“œ: ë‘˜ ë‹¤ ì‚¬ìš© (ì¶”ì²œ)

### ë¬´íš¨í™”

- ìˆ˜ë™: ëª…ì‹œì  ì‚­ì œ
- ìë™: ì‹œìŠ¤í…œ ì´ë²¤íŠ¸ ë°˜ì‘
- ETag: ì„œë²„ ê¸°ë°˜ ì¬ê²€ì¦

### íˆíŠ¸ìœ¨ í–¥ìƒ

- í”„ë¦¬í˜ì¹­ìœ¼ë¡œ ë¯¸ë¦¬ ë¡œë“œ
- ì ì ˆí•œ ìºì‹œ í¬ê¸°
- ë‹¤ìš´ìƒ˜í”Œë§ìœ¼ë¡œ ë©”ëª¨ë¦¬ ì ˆì•½

---

**ë‹¤ìŒ ë‹¨ê³„**: LIBRARY_CACHE_COMPARISON.mdì—ì„œ Kingfisherì™€ Nukeì˜ ìºì‹œ êµ¬í˜„ì„ ë¹„êµí•©ë‹ˆë‹¤! ğŸ”











